256x240 @ 60fps

Background: 8x8 tiles (32x32)

Tilemap: Structure of 1-byte indices into the tile table

Tile table: Structure containing tile definitions

    Tile definitions: array of 3 bit palette indices per pixel. One row is 3 bytes (8 pixels * 3 bits = 24 bits)

Color palette: Whole palette is 6-bit (00 is transparent)

Frame palettes: 4 background palettes of 8 colors each, 8 sprite palettes of 8 colors each

    Frame background palette 0, index 0 defines the backdrop color

Palette table: 512-byte table; 2 bits per group of 2 tiles (in tilemap) sets which background palette it uses

VRAM memory map (in the larger memory map):

0000:0FFF   Work RAM
1000:17FF   Tilemap
1800:19FF   Palette table
1A00:1AFF   Sprite table
1B00:1FFF   ***
2000:2FFF   Hardware registers
3000:3FFF   Expansion port?
4000:4FFF   Tile table 0
5000:5FFF   Tile table 1
6000:FFFF   Cartridge

a (tile address) register:

    00010 yyyyy xxxxxx
          ||||| ++++++---Tile select X
          +++++----------Tile select Y

    Used to select the tile being drawn

x (pixel select x) register:

    00000 xxx

y (pixel select y) register:

    00000 yyy

Rendering: Per scanline... 108 CPU cycles per scanline.
    Iterate over all 32 tiles containing the scanline:
        Fetch the tile palette bits by getting byte (tileIndex)/4, bits at tileIndex % 4 * 2
        If the bottom 3 bits are 0 (transparent), replace with background color and skip next step
        For the relevant 3 bytes (row of 8x3) of the tile pointed to, combine with the tile palette
        Use palette-indexed color to fetch the actual RGB values of color
        Write to pixel framebuffer
        Pixel framebuffer doubled to create 2-pixel tall scanline
        Write pixel value >> 4 to the inactive scanline to simulate bleed

Cartridges:
    header:
        Board (1 byte): Motherboard used by cartridge
        Data that follows depends on board, but identifies the components on the board
    data:
        NVRAM Data: NVRAM data in order of component
        ROM Data: ROM data in order of component