#pragma once

#include <cstdint>

#include "..\displayProcessor.hpp"
#include "..\signaledDevice.hpp"
#include "..\MFL.B3050\b3050.hpp"

class alignas(64) V1000 : public B3050, public displayProcessor {
    // VRAM memory map
    const static uint16_t VRAM_BASE = 0x1000;
    const static uint16_t TM_OFFSET = 0x0000;
    const static uint16_t PT_OFFSET = 0x0800;
    // Cartridge memory map
    const static uint16_t TT0_BASE = 0x4000;
    const static uint16_t TT1_BASE = 0x5000;
    // Internal memory map
    const static uint8_t BP_OFFSET = 0x00;
    const static uint8_t SP_OFFSET = 0x20;
    const static uint8_t AS_OFFSET = 0x40;
    const static uint8_t ST_OFFSET = 0x60;
    // Display constants
    const uint32_t PIXELS_PER_SCANLINE         = 256;
    const uint32_t REAL_PIXELS_PER_SCANLINE    = PIXELS_PER_SCANLINE * 3;
    const uint32_t BYTES_PER_SCANLINE          = REAL_PIXELS_PER_SCANLINE * 4;
    const uint32_t VISIBLE_SCANLINES_PER_FRAME = 240;
    const uint32_t SCANLINES_PER_FRAME         = 262;
    const uint32_t CYCLES_PER_SCANLINE         = 108;
private:
    struct {
        uint8_t r, g, b;
    } displayColors[64] = {
        {0xff, 0xff, 0xff},
        {0xff, 0xb3, 0xb3},
        {0xff, 0xe0, 0xb3},
        {0xff, 0xf8, 0xb3},
        {0xc2, 0xff, 0xb3},
        {0xb3, 0xff, 0xd1},
        {0xb3, 0xff, 0xff},
        {0xb3, 0xd1, 0xff},
        {0xb9, 0xc5, 0xff},
        {0xf0, 0xb3, 0xff},
        {0xff, 0xb3, 0xe1},
        {0xbf, 0xbf, 0xbf},
        {0xff, 0x66, 0x66},
        {0xff, 0xc2, 0x66},
        {0xff, 0xf0, 0x66},
        {0x84, 0xff, 0x66},
        {0x66, 0xff, 0xa3},
        {0x66, 0xff, 0xff},
        {0x66, 0xa4, 0xff},
        {0x84, 0x66, 0xff},
        {0xe1, 0x66, 0xff},
        {0xff, 0x66, 0xc3},
        {0x40, 0x40, 0x40},
        {0xff, 0x1a, 0x1a},
        {0xff, 0xa3, 0x1a},
        {0xff, 0xe9, 0x1a},
        {0x47, 0xff, 0x1a},
        {0x1a, 0xff, 0x76},
        {0x1a, 0xff, 0xff},
        {0x1a, 0x76, 0xff},
        {0x46, 0x1a, 0xff},
        {0xd2, 0x1a, 0xff},
        {0xff, 0x1a, 0xa5},
        {0x00, 0x00, 0x00},
        {0xcc, 0x00, 0x00},
        {0xcc, 0x7a, 0x00},
        {0xcc, 0xb8, 0x00},
        {0x28, 0xcc, 0x00},
        {0x00, 0xcc, 0x52},
        {0x00, 0xcc, 0xcc},
        {0x00, 0x52, 0xcc},
        {0x28, 0x00, 0xcc},
        {0xa4, 0x00, 0xcc},
        {0xcc, 0x00, 0x7c},
        {0x80, 0x00, 0x00},
        {0x80, 0x4c, 0x00},
        {0x80, 0x73, 0x00},
        {0x19, 0x80, 0x00},
        {0x00, 0x80, 0x33},
        {0x00, 0x80, 0x7f},
        {0x00, 0x33, 0x80},
        {0x19, 0x00, 0x80},
        {0x67, 0x00, 0x80},
        {0x80, 0x00, 0x4e},
        {0x33, 0x00, 0x00},
        {0x33, 0x1f, 0x00},
        {0x33, 0x2e, 0x00},
        {0x0a, 0x33, 0x00},
        {0x00, 0x33, 0x14},
        {0x00, 0x33, 0x33},
        {0x00, 0x15, 0x33},
        {0x0a, 0x00, 0x33},
        {0x29, 0x00, 0x33},
        {0x33, 0x00, 0x1f},
    };
    uint32_t *scanlineBuffer;
    uint8_t   pixelPaletteIndexes[33 * 8] {};
public:
    struct {
        struct {
            uint8_t x;
            uint8_t y;
        } pixel, tile;
        uint8_t ctrl;
        uint8_t mem[64 + 32 + 256];
    } real, temp;
    V1000();
    bool     initialize(signaledDevice *sh, B2000 *d, B2100 *a, B2310 *crw, B2310 *cnmi, B2310 *cirq) override;
    uint32_t signal() override;
    uint32_t dispatchEvent(uint8_t index, uint8_t data[4]) override;
private:
    uint32_t renderScanline(uint8_t data[4]);
    uint32_t vBlank(uint8_t data[4]);
    uint32_t hBlank(uint8_t data[4]);
};
